Packaging up libshogun for use inside shikken
=============================================

Proper configuration/compilation of libshogun requires some post-processing
in order to generate some files before make/install. The following files
need to be generated:
  
  * lib/config.h : This can *probably* be rolled into the normal R CMD INSTALL
    workflow since this is simply a list of #define macros that are generated
    after system functionality detection
    
  * base/class_list.cpp : This probably can't be rolled into the normal
    R CMD INSTALL mojo since it invokes base/clase_lsit_cpp.py in order
    to generate it.

This means that if you want to include a new libshogun src tree inside
shikken, you have to ensure these files are generated.

TODO: Ensure R CMD INSTALL process defined appropriate -DFLAGS by doing
      proper system detection
TODO: Enable the user to specify that they want to use their own installed
      version of libshogun in the same way RSQLite allows you to specify
      using the system installed libsqlite library

Creating External Shogun Objects
================================

A call to `SVM` requires that we build several objects for the final svm.
For instance, we have to:

 (i)   Convert the features matrix from the R side, to a CSimpleFeatures
       object on the C++ side.
 (ii)  Create a kernel/Kernel object from the features in (i)
 (iii) Initialize an SVM with the kernel object (ii) and the features (i)
 (iv)  Train the SVM
  ...

Overview
--------

I think to make this as "clean" as possible, we have to build each object
individually and not just call one "monster" function. In order to do so,
a `createKernel` type of function will need to build a shogun/Kernel object
on the "C" side of things and return a pointer to this back to R.

* When creating these "modular" shogun objects, I think we have to call
  SG_REF(object) so they are not disposed. Similarly, when the object is
  R-garbage collected, ensure that the method invoked on GC (see below)
  must call SG_UNREF(object).

* The R class will have to have a slot of "externalptr" type.
  Section 5.13 of the R-exts document introduces `ExternalPtr`.
  
    * You can register finalizers to external pointers that is run when
      it is garbage collected. This can be R or C code, and the various 
      interfaces are, respectively:
      
        void R_RegisterFinalizerEx(SEXP s, SEXP fun, Rboolean onexit);
        typedef void (*R_CFinalizer_t)(SEXP);
        void R_RegisterCFinalizerEx(SEXP s, R_CFinalizer_t fun, Rboolean onexit);

* Rcpp has an XPtr<T> type you will probably want to use. Read through
  Rcpp-modules vignette.

Summary
-------

Currently the solution is to handle the finalizer callbacks at the C level by
invoking the SK_WRAP macro, which accepts:

 (i) a pointer to CSGObject; and
 (ii) a SEXP object to wrap the CSGObject into.

SK_WRAP wraps the CSGOjbect with the SEXP and registers the appropriate
finalier, eg:
  
  #define SK_WRAP(o,r) \
  do { \
      r = R_MakeExternalPtr(o, R_NilValue, R_NilValue); \
      R_RegisterCFinalizer(r, _shogun_ref_count_down); \
  } while(0)

So, to create an arbitrarily kernel:
  
  SEXP out;
  
  ...
  CGaussianKernel* kernel = new CGaussianKernel(cache_size, width);
  kernel->init(fptr, fptr); // kernel->init(features, features);
  
  SG_REF(kernel);
  SK_WRAP(kernel, out);
  
  return out;
  
~~ IMPORTANT ~~

Investigate if accessing "embedded" shogun objects is dangerous.
For instance, do we need to forbid reassignment like so:

  extracted.reatures <- some.kernel@features

The features slot of a Kernel is also a Shogun object, so how does the
ref counting go -- maybe this is better:

  extracted.features <- features(some.kernel)

so that we can bump up the shogun reference count for the features object
by invoking SG_REF somehow at the C level?



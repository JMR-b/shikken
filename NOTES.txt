Packaging up libshogun for use inside shikken
=============================================

Proper configuration/compilation of libshogun requires some post-processing
in order to generate some files before make/install. The following files
need to be generated:
  
  * lib/config.h : This can *probably* be rolled into the normal R CMD INSTALL
    workflow since this is simply a list of #define macros that are generated
    after system functionality detection
    
  * base/class_list.cpp : This probably can't be rolled into the normal
    R CMD INSTALL mojo since it invokes base/clase_lsit_cpp.py in order
    to generate it.

This means that if you want to include a new libshogun src tree inside
shikken, you have to ensure these files are generated.

Once the files above are created in the appropriate place, move shogun's
`src/libshogun` directory to `shikken/src/shogun`

TODO: Ensure R CMD INSTALL process defined appropriate -DFLAGS by doing
      proper system detection.

TODO: Enable the user to specify that they want to use their own installed
      version of libshogun in the same way RSQLite allows you to specify
      using the system installed libsqlite library


Shogun memory management and R
==============================

The shogun-toolbox implements its own reference counting-type garbage
collection scheme. Each CSGObject keeps its own reference count, and
when another object references it, its count is incremented (and
decremented when appropriate).

When CSGObjects are passed back to R, their SG_REF is incremented so that
the object isn't lost between the C <--> R interplay. This requires R to
invoke SG_UNREF when R garbage collects the object.

To do this, we are using R's register-finalizer functionality which are
associated with R's `externalptr` objects that point to CSGObjects. These are
described in ~ Section 5.13 of the R-exts document. Finalizers to externalptr's
can be registered using R or C code, and these finalizers are run when the R
object is garbage collected, eg. on the C side:

    void R_RegisterFinalizerEx(SEXP s, SEXP fun, Rboolean onexit);
    typedef void (*R_CFinalizer_t)(SEXP);
    void R_RegisterCFinalizerEx(SEXP s, R_CFinalizer_t fun, Rboolean onexit);

shikken currently handles the finalizer callbacks at the C level by
invoking the SK_WRAP macro on a CSGObject that is being sent back to R. The
SK_WRAP macro is defined in src/shikken.h. It accepts:

 (i) a pointer to CSGObject; and
 (ii) a SEXP object to wrap the CSGObject into.

    #define SK_WRAP(o,r) \
    do { \
        r = R_MakeExternalPtr(o, R_NilValue, R_NilValue); \
        R_RegisterCFinalizer(r, _shogun_ref_count_down); \
    } while(0)

A "mostly real" example that creates a gaussian kernel would be like so:

    SEXP out;
    // ...
    // code to setup appropriate kernel params
    // ...
    CGaussianKernel* kernel = new CGaussianKernel(cache_size, width);
    kernel->init(fptr, fptr); // kernel->init(features, features);
    SG_REF(kernel);          // increments the shogun ref count for the object
    
    // we now initialize `out` as an R-externalptr, and register a finalizer
    // method that is called when R eventually garbage-collects the externalptr
    SK_WRAP(kernel, out);    
    
    return out;

IMPORTANT
---------

Investigate if accessing "embedded" shogun objects is dangerous.
For instance, do we need to forbid reassignment like so:

  extracted.reatures <- some.kernel@features

The features slot of a Kernel is also a Shogun object, so how does the
ref counting go -- maybe this is better:

  extracted.features <- features(some.kernel)

so that we can bump up the shogun reference count for the features object
by invoking SG_REF somehow at the C level?


